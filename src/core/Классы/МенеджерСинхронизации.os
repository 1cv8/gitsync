///////////////////////////////////////////////////////////////////////////////////////////////
//
// Модуль основан на проекте v83unpack (https://github.com/xDrivenDevelopment/v83unpack)
// и является скорее глубоким рефакторингом под 1Script, нежели самостоятельной разработкой.
//
// Использует также утилиту Tool_1CD от awa (http://infostart.ru/public/19633/)
//
///////////////////////////////////////////////////////////////////////////////////////////////

#Использовать logos
#Использовать tempfiles
#Использовать v8runner
#Использовать v8storage
#Использовать strings
#Использовать 1commands
#Использовать gitrunner
#Использовать fs
#Использовать "./internal"

Перем Лог;
Перем ЭтоWindows;
Перем УдалятьВременныеФайлы;
Перем КоличествоЦикловОжиданияЛицензииПоУмолчанию;

Перем РабочийКаталогСохр;
Перем ГитРепозиторийСохр;
// Определяем мин количество коммитов между разницей версии уже в git и в хранилище
// для случаев, когда пересоздали хранилище и в гите находится версия 1234, а в хранилище 4,
// тогда вызываем исключение если разница в коммитах больше чем на эту велечину.
Перем МинимальнаяРазницаМеждуКоммитамиНовогоХранилища;
Перем ОбработчикПодписок;

Перем ХранилищеКонфигурации;
Перем АвторизацияВХранилище;

///////////////////////////////////////////////////////////////////////////////////////////////
// ПРОГРАММНЫЙ ИНТЕРФЕЙС

Перем ДоменПочтыДляGitПоУмолчанию Экспорт;
Перем ВерсияПлатформы Экспорт;

#Область Публичное_API

Функция АвторизацияВХранилищеКонфигурации(Знач Пользователь, Знач Пароль) Экспорт

	Лог.Отладка("Установлена авторизация в хранилище пользователь <%1>, пароль <%2>", Пользователь, Пароль);
	АвторизацияВХранилище.Вставить("ПользовательХранилища" , Пользователь);
	АвторизацияВХранилище.Вставить("ПарольХранилища", Пароль);

	Возврат ЭтотОбъект;

КонецФункции

Функция РежимУдаленияВременныхФайлов(Знач ПарамУдалятьВременныеФайлы) Экспорт

	УдалятьВременныеФайлы = ПарамУдалятьВременныеФайлы;

	Возврат ЭтотОбъект;

КонецФункции

Функция ПодпискиНаСобытия(Знач НовыйОбработчикПодписок) Экспорт

	УстановитьОбработчикПодписок(НовыйОбработчикПодписок);

	Возврат ЭтотОбъект;

КонецФункции

Функция ЦикловОжиданияЛицензии(Знач КоличествоЦиклов) Экспорт

	КоличествоЦикловОжиданияЛицензииПоУмолчанию = КоличествоЦиклов;
	Возврат ЭтотОбъект;

КонецФункции

Функция УровеньЛога(Знач НовыйУровньЛога) Экспорт

	Лог.УстановитьУровень(НовыйУровньЛога);
	Возврат ЭтотОбъект;

КонецФункции

Функция ВерсияПлатформы(Знач НоваяВерсияПлатформы) Экспорт

	ВерсияПлатформы = НоваяВерсияПлатформы;
	Возврат ЭтотОбъект;

КонецФункции

// Основная функция синхронизации.
// Перемещает в git набор коммитов хранилища 1С
//
// Параметры:
//   КаталогРабочейКопии - Строка - Путь к каталогу рабочей копии 
//   ПутьКХранилищу - Строка - путь к хранилищу конфигурации
//
Процедура Синхронизировать(Знач КаталогРабочейКопии,
						Знач ПутьКХранилищу) Экспорт

	ОбработчикПодписок.ПередНачаломВыполнения(ПутьКХранилищу, КаталогРабочейКопии);

	Лог.Информация("Начата синхронизация с git");

	НастроитьХранилищеКонфигурации(ПутьКХранилищу, АвторизацияВХранилище);

	ТаблицаИсторииХранилища = ПрочитатьИзХранилищаИсториюКоммитовСАвторами(ПутьКХранилищу);

	ДополнитьТаблицуХранилищаИнформациейОСигнатуреПользователяВГит(ТаблицаИсторииХранилища, КаталогРабочейКопии);

	ТекущаяВерсия = НомерСинхронизированнойВерсии(КаталогРабочейКопии);

	Лог.Информация("Номер синхронизированной версии: " + ТекущаяВерсия);
	СледующаяВерсия = ТекущаяВерсия + 1;

	МаксимальнаяВерсияДляРазбора = ОпределитьМаксимальнуюВерсиюВХранилище(ТаблицаИсторииХранилища);
	Лог.Информация("Номер последней версии в хранилище: " + МаксимальнаяВерсияДляРазбора);

	Если СледующаяВерсия > МаксимальнаяВерсияДляРазбора 
		И СледующаяВерсия - МаксимальнаяВерсияДляРазбора > МинимальнаяРазницаМеждуКоммитамиНовогоХранилища Тогда
		
		Лог.Ошибка("Несоответствие версий хранилища 1С и версию в репозитории Git.
		|Возможно, сократили/обрезали хранилище.
		|Для продолжения синхронизации измените файл VERSIONS в корне репозитория Git,
		|Исправьте версию %1 на правильную версию <= версии в хранилище %2", ТекущаяВерсия, МаксимальнаяВерсияДляРазбора);

		ВызватьИсключение СтрШаблон("Версия git %1 больше версии хранилища %2 на %3", 
									ТекущаяВерсия,
									МаксимальнаяВерсияДляРазбора,
									СледующаяВерсия - МаксимальнаяВерсияДляРазбора);
	КонецЕсли;

	ОбработчикПодписок.ПередНачаломЦиклаОбработкиВерсий(ТаблицаИсторииХранилища,
														ТекущаяВерсия,
														СледующаяВерсия,
														МаксимальнаяВерсияДляРазбора);

	Пока СледующаяВерсия <= МаксимальнаяВерсияДляРазбора Цикл

		СтрокаВерсии = ТаблицаИсторииХранилища.Найти(СледующаяВерсия, "НомерВерсии");
		Если СтрокаВерсии <> Неопределено Тогда

			ОбработчикПодписок.ПередОбработкойВерсииХранилища(СтрокаВерсии, СледующаяВерсия);

			Попытка
				Лог.Информация("Получаем исходники для версии " + СледующаяВерсия + ", " + ТекущаяДата());

				ОбработчикПодписок.ПриОбработкеВерсииХранилища(СтрокаВерсии, СледующаяВерсия);
				ВыгрузитьВерсиюХранилищаКонфигурацииВИсходники(КаталогРабочейКопии, ПутьКХранилищу, СледующаяВерсия);

				Лог.Отладка("Фиксируем в файле VERSION версию " + СледующаяВерсия);
				ЗаписатьФайлВерсийГит(КаталогРабочейКопии, СледующаяВерсия);
				ВыполнитьКоммитГит(КаталогРабочейКопии,
									СтрокаВерсии.Комментарий,
									СтрокаВерсии.ПредставлениеАвтора,
									СтрокаВерсии.Дата);


			Исключение
				Лог.Отладка("Откатываем файл VERSION после ошибки");
				ЗаписатьФайлВерсийГит(КаталогРабочейКопии, ТекущаяВерсия);
				ВызватьИсключение;
			КонецПопытки;

			ТекущаяВерсия = СледующаяВерсия;
			ОбработчикПодписок.ПослеОбработкиВерсииХранилища(СтрокаВерсии, ТекущаяВерсия);

		КонецЕсли;

		СледующаяВерсия = СледующаяВерсия + 1;

	КонецЦикла;

	ЗавершитьПроцесс_TGitCache_exe();

	ОбработчикПодписок.ПослеОкончанияВыполнения(ПутьКХранилищу, КаталогРабочейКопии);

	УдалитьВременныеФайлыПриНеобходимости();

	Лог.Информация("Завершена синхронизации с git");

КонецПроцедуры

#КонецОбласти

#Область ОБРАБОТКА_ВЕРСИИ_КОНФИГУРАЦИИ

////////////////////////////////
// ОБРАБОТКА ВЕРСИИ КОНФИГУРАЦИИ

// <Описание процедуры>
//
// Параметры:
//   КаталогРабочейКопии - <Тип.Вид> - <описание параметра>
//   ПутьКХранилищу - <Тип.Вид> - <описание параметра>
//   НомерВерсии - <Тип.Вид> - <описание параметра>
//
Процедура ВыгрузитьВерсиюХранилищаКонфигурацииВИсходники(Знач КаталогРабочейКопии,
														Знач ПутьКХранилищу,
														Знач НомерВерсии) Экспорт

	Конфигуратор = ПолучитьМенеджерКонфигуратора();

	ОбработчикПодписок.ПередНачаломВыгрузкиВерсииХранилищаКонфигурации(Конфигуратор,
																		КаталогРабочейКопии,
																		ПутьКХранилищу,
																		НомерВерсии);

	ОбработчикПодписок.ПередЗагрузкойВерсииХранилищаКонфигурации(Конфигуратор,
																КаталогРабочейКопии,
																ПутьКХранилищу,
																НомерВерсии);

	ЗагрузитьВерсиюХранилищаВКонфигурацию(Конфигуратор, КаталогРабочейКопии, ПутьКХранилищу, НомерВерсии);

	КаталогВыгрузки = ВременныеФайлы.СоздатьКаталог();

	Лог.Отладка("Каталог выгрузки <%1> для версии <%2>", КаталогВыгрузки , НомерВерсии);

	ОбработчикПодписок.ПередВыгрузкойКонфигурациюВИсходники(Конфигуратор,
															КаталогРабочейКопии,
															КаталогВыгрузки,
															ПутьКХранилищу,
															НомерВерсии);

	ВыгрузитьКонфигурациюВИсходники(Конфигуратор, КаталогВыгрузки);

	ОбработчикПодписок.ПередОчисткойКаталогаРабочейКопии(Конфигуратор,
														КаталогРабочейКопии,
														КаталогВыгрузки,
														ПутьКХранилищу,
														НомерВерсии);
	
	ОчиститьКаталогРабочейКопии(КаталогРабочейКопии);

	ОбработчикПодписок.ПередПеремещениемВКаталогРабочейКопии(Конфигуратор,
															КаталогРабочейКопии,
															КаталогВыгрузки,
															ПутьКХранилищу,
															НомерВерсии);

	ПереместитьВКаталогРабочейКопии(КаталогРабочейКопии, КаталогВыгрузки);

	ОбработчикПодписок.ПослеОкончанияВыгрузкиВерсииХранилищаКонфигурации(Конфигуратор,
																		КаталогРабочейКопии,
																		ПутьКХранилищу,
																		НомерВерсии);

	УдалитьВременныеФайлыПриНеобходимости(Конфигуратор.КаталогСборки());
	УдалитьВременныеФайлыПриНеобходимости(КаталогВыгрузки);

КонецПроцедуры

// <Описание процедуры>
//
// Параметры:
//   Конфигуратор - <Тип.Вид> - <описание параметра>
//   КаталогРабочейКопии - <Тип.Вид> - <описание параметра>
//   ПутьКХранилищу - <Тип.Вид> - <описание параметра>
//   НомерВерсии - <Тип.Вид> - <описание параметра>
//
Процедура ЗагрузитьВерсиюХранилищаВКонфигурацию(Знач Конфигуратор,
												Знач КаталогРабочейКопии,
												Знач ПутьКХранилищу,
												Знач НомерВерсии) Экспорт
	СтандартнаяОбработка = Истина;

	ОбработчикПодписок.ПриЗагрузкеВерсииХранилищаВКонфигурацию(Конфигуратор,
																КаталогРабочейКопии,
																ПутьКХранилищу,
																НомерВерсии,
																СтандартнаяОбработка);

	Если СтандартнаяОбработка Тогда

		ЗагрузитьВерсиюХранилищаВКонфигурациюСтандартнаяОбработка(Конфигуратор,
																НомерВерсии);

	КонецЕсли;

	ОбработчикПодписок.ПослеЗагрузкиВерсииХранилищаВКонфигурацию(Конфигуратор,
																КаталогРабочейКопии,
																ПутьКХранилищу,
																НомерВерсии);

КонецПроцедуры

Процедура ЗагрузитьВерсиюХранилищаВКонфигурациюСтандартнаяОбработка(Конфигуратор,
																	Знач НомерВерсии)
	
	ХранилищеКонфигурации.УстановитьУправлениеКонфигуратором(Конфигуратор);

	КоличествоЦикловОжиданияЛицензии = ПолучитьКоличествоЦикловОжиданияЛицензииПоУмолчанию();

	Пока КоличествоЦикловОжиданияЛицензии >= 0 Цикл
		Попытка

			ХранилищеКонфигурации.ОбновитьКонфигурациюНаВерсию(НомерВерсии);
			Прервать;

		Исключение
			// проверим текст ошибки, если текст содержит информацию о необходимости конвертировать
			// тогда выполним конвертацию и повторно попытаемся загрузить файл
			ТекстОшибки = ВРег(ХранилищеКонфигурации.ПолучитьВыводКоманды());
			Если Найти(ТекстОшибки, Врег("Не обнаружено свободной лицензии!")) Тогда
				Лог.Ошибка(ТекстОшибки);
				Лог.Информация("Повторное подключение через 10сек. Осталось попыток: " + КоличествоЦикловОжиданияЛицензии);
				Приостановить(10000);

			Иначе

				ВызватьИсключение ТекстОшибки;

			КонецЕсли;

		КонецПопытки;

		Если ПолучитьКоличествоЦикловОжиданияЛицензииПоУмолчанию() <> 0 Тогда
			КоличествоЦикловОжиданияЛицензии = КоличествоЦикловОжиданияЛицензии - 1;
		КонецЕсли;

	КонецЦикла;

КонецПроцедуры

// <Описание процедуры>
//
// Параметры:
//   Конфигуратор - <Тип.Вид> - <описание параметра>
//   КаталогВыгрузки - <Тип.Вид> - <описание параметра>
//
Процедура ВыгрузитьКонфигурациюВИсходники(Знач Конфигуратор, Знач КаталогВыгрузки) Экспорт

	СтандартнаяОбработка = Истина;

	ОбработчикПодписок.ПриВыгрузкеКонфигурациюВИсходники(Конфигуратор, КаталогВыгрузки, СтандартнаяОбработка);

	Если СтандартнаяОбработка Тогда

		Конфигуратор.ВыгрузитьКонфигурациюВФайлы(КаталогВыгрузки);

	КонецЕсли;

	ОбработчикПодписок.ПослеВыгрузкиКонфигурациюВИсходники(Конфигуратор, КаталогВыгрузки);

КонецПроцедуры

// <Описание процедуры>
//
// Параметры:
//   КаталогРабочейКопии - <Тип.Вид> - <описание параметра>
//
Процедура ОчиститьКаталогРабочейКопии(Знач КаталогРабочейКопии) Экспорт

	СтандартнаяОбработка = Истина;

	СоответствиеИменФайловДляПропуска = Новый Соответствие;
	СоответствиеИменФайловДляПропуска.Вставить(".git", Истина);
	СоответствиеИменФайловДляПропуска.Вставить(ИмяФайлаАвторов(), Истина); // Соответствие авторов и транслитерации.
	СоответствиеИменФайловДляПропуска.Вставить(ИмяФайлаВерсииХранилища(), Истина); // Номер версии, может использоватся для синхронизации с хранилищем.

	ОбработчикПодписок.ПриОчисткеКаталогаРабочейКопии(КаталогРабочейКопии,
													 СоответствиеИменФайловДляПропуска,
													 СтандартнаяОбработка);

	Если СтандартнаяОбработка Тогда

		ОчиститьКаталогРабочейКопииСтандартнаяОбработка(КаталогРабочейКопии, СоответствиеИменФайловДляПропуска);

	КонецЕсли;

	ОбработчикПодписок.ПослеОчисткиКаталогаРабочейКопии(КаталогРабочейКопии, СоответствиеИменФайловДляПропуска);

КонецПроцедуры

Процедура ОчиститьКаталогРабочейКопииСтандартнаяОбработка(Знач КаталогРабочейКопии, СоответствиеИменФайловДляПропуска)
	
	ЕстьОшибкаУдаления = Ложь;
	КоличествоПопыток = 2;
	Для НомерПопытки = 1 По КоличествоПопыток Цикл
		МассивФайлов = НайтиФайлы(КаталогРабочейКопии, ПолучитьМаскуВсеФайлы());
		Если МассивФайлов.Количество() = 0 Тогда
			Прервать;
		КонецЕсли;

		Для Каждого ЭлементМассива Из МассивФайлов Цикл
			Если СоответствиеИменФайловДляПропуска[ЭлементМассива.Имя] = Истина Тогда
				Продолжить;
			КонецЕсли;

			Попытка
				УдалитьФайлы(ЭлементМассива.ПолноеИмя);
			Исключение
				ЕстьОшибкаУдаления = Истина;
				Если НомерПопытки = КоличествоПопыток Тогда
					ВызватьИсключение;
				КонецЕсли;
			КонецПопытки;
		КонецЦикла;

		Если Не ЕстьОшибкаУдаления Тогда
			Прервать;
		КонецЕсли;

	КонецЦикла;

КонецПроцедуры

// <Описание процедуры>
//
// Параметры:
//   КаталогРабочейКопии - <Тип.Вид> - <описание параметра>
//   КаталогВыгрузки - <Тип.Вид> - <описание параметра>
//
Процедура ПереместитьВКаталогРабочейКопии(Знач КаталогРабочейКопии, Знач КаталогВыгрузки) Экспорт

	СтандартнаяОбработка = Истина;

	ТаблицаПереименования = Новый ТаблицаЗначений;
	ТаблицаПереименования.Колонки.Добавить("Источник");
	ТаблицаПереименования.Колонки.Добавить("Приемник");

	ПутьКФайлуПереименования = ОбъединитьПути(КаталогРабочейКопии, "renames.txt");

	ОбработчикПодписок.ПриПеремещенииВКаталогРабочейКопии(КаталогРабочейКопии,
														КаталогВыгрузки,
														ТаблицаПереименования,
														ПутьКФайлуПереименования,
														СтандартнаяОбработка);

	Если СтандартнаяОбработка Тогда

		ПереместитьВКаталогРабочейКопииСтандартнаяОбработка(КаталогРабочейКопии,
															КаталогВыгрузки,
															ТаблицаПереименования);

	КонецЕсли;

	ОбработчикПодписок.ПослеПеремещенияВКаталогРабочейКопии(КаталогРабочейКопии,
															КаталогВыгрузки,
															ТаблицаПереименования,
															ПутьКФайлуПереименования);

КонецПроцедуры

Процедура ПереместитьВКаталогРабочейКопииСтандартнаяОбработка(Знач КаталогРабочейКопии,
															Знач КаталогВыгрузки,
															ТаблицаПереименования)
															
	СписокФайлов = НайтиФайлы(КаталогВыгрузки, ПолучитьМаскуВсеФайлы(), Истина);
	Лог.Отладка("Найдено файлов выгрузки: %1 шт.", СписокФайлов.Количество());
	Лог.Отладка("КаталогРабочейКопии: %1 ", КаталогРабочейКопии);
	Для Каждого Файл Из СписокФайлов Цикл

		КорневойКаталог = КаталогВыгрузки;
		Если НЕ СтрЗаканчиваетсяНа(КорневойКаталог, ПолучитьРазделительПути()) Тогда
			КорневойКаталог = КорневойКаталог + ПолучитьРазделительПути();
		КонецЕсли;

		ИмяНовогоФайла = СтрЗаменить(Файл.ПолноеИмя, КорневойКаталог, "");

		Если Файл.ЭтоКаталог() Тогда

			ИмяКаталога = ОбъединитьПути(КаталогРабочейКопии, ИмяНовогоФайла);
			Лог.Отладка("Обрабатываю ИмяКаталога: %1 ", ИмяКаталога);
			ФайлКаталога = Новый Файл(ИмяКаталога);
			Если НЕ ФайлКаталога.Существует() Тогда
				СоздатьКаталог(ФайлКаталога.ПолноеИмя);
			КонецЕсли;

			Продолжить;

		КонецЕсли;

		НовыйФайл = Новый Файл(ОбъединитьПути(КаталогРабочейКопии, ИмяНовогоФайла));
		НовыйКаталог = Новый Файл(НовыйФайл.Путь);
		Если НЕ НовыйКаталог.Существует() Тогда
			СоздатьКаталог(НовыйКаталог.ПолноеИмя);
		КонецЕсли;

		КопироватьФайл(Файл.ПолноеИмя, НовыйФайл.ПолноеИмя);

		НовоеПереименование = ТаблицаПереименования.Добавить();
		НовоеПереименование.Источник = Файл.ПолноеИмя;
		НовоеПереименование.Приемник = НовыйФайл.ПолноеИмя;

	КонецЦикла;

КонецПроцедуры

#КонецОбласти

#Область РАБОТА_С_КОНФИГУРАТОРОМ

// <Описание функции>
//
//  Возвращаемое значение:
//   <Тип.Вид> - <описание возвращаемого значения>
//
Функция ПолучитьМенеджерКонфигуратора() Экспорт
	Конфигуратор = Новый УправлениеКонфигуратором;
	Логирование.ПолучитьЛог("oscript.lib.v8runner").УстановитьУровень(Лог.Уровень());
	КаталогСборки = ВременныеФайлы.СоздатьКаталог();
	Конфигуратор.КаталогСборки(КаталогСборки);
	Конфигуратор.ИспользоватьВерсиюПлатформы(ВерсияПлатформы);

	Возврат Конфигуратор;
КонецФункции

Процедура НастроитьХранилищеКонфигурации(Знач ПутьКХранилищу, Знач ПараметрыАвторизацииВХранилище)

	Если ХранилищеКонфигурации = Неопределено Тогда
		ХранилищеКонфигурации = Новый МенеджерХранилищаКонфигурации;
		Конфигуратор = ХранилищеКонфигурации.ПолучитьУправлениеКонфигуратором();
		Конфигуратор.ИспользоватьВерсиюПлатформы("8.3");
	КонецЕсли;

	Логирование.ПолучитьЛог("oscript.lib.v8storage").УстановитьУровень(Лог.Уровень());
	ПроверитьПараметрыДоступаКХранилищу();
	ХранилищеКонфигурации.УстановитьПараметрыАвторизации(ПараметрыАвторизацииВХранилище.ПользовательХранилища,
														ПараметрыАвторизацииВХранилище.ПарольХранилища);
	ХранилищеКонфигурации.УстановитьПутьКХранилищу(ПутьКХранилищу);

КонецПроцедуры

// <Описание процедуры>
//
Процедура ПроверитьПараметрыДоступаКХранилищу() Экспорт

	Если АвторизацияВХранилище.ПользовательХранилища = Неопределено
		ИЛИ ПустаяСтрока(АвторизацияВХранилище.ПользовательХранилища) Тогда

		ВызватьИсключение "Не задан пользователь хранилища конфигурации.";

	КонецЕсли;

	Если АвторизацияВХранилище.ПарольХранилища = Неопределено Тогда

		АвторизацияВХранилище.ПарольХранилища = "";

	КонецЕсли;

КонецПроцедуры // ПроверитьПараметрыДоступаКХранилищу

#КонецОбласти

#Область РАБОТА_С_GIT

/////////////////////////////////////
// GIT Пересмотр

Функция ПолучитьГитРепозиторий(Знач КаталогРабочейКопии) Экспорт

	ФайлКаталога = Новый Файл(КаталогРабочейКопии);
	Если ФайлКаталога.ПолноеИмя = РабочийКаталогСохр Тогда
		ГитРепозиторий = ГитРепозиторийСохр;
	Иначе
		ГитРепозиторий = Новый ГитРепозиторий;
		ГитРепозиторий.УстановитьРабочийКаталог(КаталогРабочейКопии);
		ГитРепозиторий.УстановитьТихийРежимРаботы();

		ГитРепозиторий.УстановитьНастройку("core.quotepath", "false", РежимУстановкиНастроекGit.Локально);
		ГитРепозиторий.УстановитьНастройку("merge.ours.driver", "true", РежимУстановкиНастроекGit.Локально);

		ГитРепозиторий.УстановитьНормальныйРежимРаботы();

		РабочийКаталогСохр = ФайлКаталога.ПолноеИмя;
		ГитРепозиторийСохр = ГитРепозиторий;

	КонецЕсли;

	Возврат ГитРепозиторий;

КонецФункции // ПолучитьГитРепозиторий()

// Выполняет фиксацию изменений в локальном каталоге git
//
Процедура ВыполнитьКоммитГит(Знач КаталогРабочейКопии, Знач Комментарий, Знач Автор, Знач Дата = Неопределено) Экспорт

	ОбработчикПодписок.ПередКоммитом(КаталогРабочейКопии, Комментарий, Автор, Дата);

	Если Дата = Неопределено Тогда
		Дата = ТекущаяДата();
	КонецЕсли;

	авторДляГит = Автор;

	Лог.Отладка("Автор коммита: %1", авторДляГит);
	ДатаДляГит = ДатаPOSIX(Дата);
	Лог.Отладка("Дата коммита: %1", ДатаДляГит);
	ИмяФайлаКомментария = ПодготовитьФайлКоммита(Комментарий);

	ГитРепозиторий = ПолучитьГитРепозиторий(КаталогРабочейКопии);
	ПроиндексироватьОтслеживаемыеФайлы = Истина;
	// Выполнение индексации всех измененных файлов
	ОбработчикПодписок.ПриКоммите(ГитРепозиторий,
				Комментарий,
				ПроиндексироватьОтслеживаемыеФайлы,
				ИмяФайлаКомментария,
				авторДляГит,
				ДатаДляГит,
				авторДляГит,
				ДатаДляГит);

	ГитРепозиторий.ВыполнитьКоманду(СтрРазделить("add -A .", " "));
	ГитРепозиторий.Закоммитить(Комментарий,
								ПроиндексироватьОтслеживаемыеФайлы,
								ИмяФайлаКомментария,
								авторДляГит,
								ДатаДляГит,
								авторДляГит,
								ДатаДляГит);
	Лог.Отладка("Вывод команды Commit: %1", СокрЛП(ГитРепозиторий.ПолучитьВыводКоманды()));

	ОбработчикПодписок.ПослеКоммита(ГитРепозиторий, КаталогРабочейКопии);

	ЗавершитьПроцесс_TGitCache_exe();

КонецПроцедуры

Функция ПодготовитьФайлКоммита(Знач Комментарий)

	ИмяФайлаКомментария = ВременныеФайлы.СоздатьФайл("txt");
	ФайлКомментария = Новый ЗаписьТекста(ИмяФайлаКомментария, КодировкаТекста.UTF8NoBOM);
	ФайлКомментария.Записать(?(ПустаяСтрока(Комментарий), ".", Комментарий));
	ФайлКомментария.Закрыть();
	Лог.Отладка(СтрШаблон("Текст коммита: %1", Комментарий));

	Возврат ИмяФайлаКомментария;

КонецФункции

#КонецОбласти

//////////////////////////////////////////////////////////////////////////
// Работа с таблицами хранилища 1С

// Выполняет чтение таблицы VERSIONS из хранилища 1С
//
// Возвращаемое значение: ТаблицаЗначений
//
Функция ПрочитатьТаблицуИсторииХранилища(Знач ПутьКХранилищу) Экспорт

	СтандартнаяОбработка = Истина;

	ТаблицаВерсий = НоваяТаблицаИсторииВерсий();

	ОбработчикПодписок.ПриПолученииТаблицыВерсий(ТаблицаВерсий, ПутьКХранилищу, СтандартнаяОбработка);

	Если СтандартнаяОбработка Тогда

		Лог.Отладка("Получение таблицы версий средствами 1С.Предприятие");
		Если ХранилищеКонфигурации = Неопределено Тогда
			НастроитьХранилищеКонфигурации(ПутьКХранилищу, АвторизацияВХранилище);
		КонецЕсли;

		ТаблицаВерсийХранилища = ХранилищеКонфигурации.ПолучитьТаблицуВерсий();

		Для Каждого СтрокаВерсииХранилища Из ТаблицаВерсийХранилища Цикл

			СтрокаВерсии = ТаблицаВерсий.Добавить();
			СтрокаВерсии.НомерВерсии	= СтроковыеФункции.СтрокаВЧисло(СтрЗаменить(СтрокаВерсииХранилища.Номер, " ", ""));
			СтрокаВерсии.Автор 			= СтрокаВерсииХранилища.Автор;
			СтрокаВерсии.ГУИД_Автора 	= СтрокаВерсииХранилища.Автор;
			СтрокаВерсии.Дата 			= СтрокаВерсииХранилища.Дата;
			СтрокаВерсии.Комментарий 	= СтрокаВерсииХранилища.Комментарий;
			СтрокаВерсии.Тэг 			= ""; // теги в отчете не предоставляются

			СтрокаШаблонаЛога = "Добавили строку в таблицу версий:
			| Номер версии: %1
			| Автор:        %2
			| ГУИД_Автора:  %3
			| Дата:         %4
			| Комментарий:  %5
			|";
			Лог.Отладка(СтрокаШаблонаЛога, СтрокаВерсии.НомерВерсии,
										СтрокаВерсии.Автор,
										СтрокаВерсии.ГУИД_Автора,
										СтрокаВерсии.Дата,
										СтрокаВерсии.Комментарий);

		КонецЦикла;

	КонецЕсли;

	ТаблицаВерсий.Сортировать("НомерВерсии");

	ОбработчикПодписок.ПослеПолученияТаблицыВерсий(ТаблицаВерсий, ПутьКХранилищу);

	Возврат ТаблицаВерсий;

КонецФункции

// Считывает таблицу USERS пользователей хранилища
//
Функция ПрочитатьТаблицуПользователейХранилища(Знач ПутьКХранилищу) Экспорт

	СтандартнаяОбработка = Истина;

	ТаблицаПользователей = НоваяТаблицаПользователейХранилища();

	ОбработчикПодписок.ПриПолученииТаблицыПользователей(ТаблицаПользователей, ПутьКХранилищу, СтандартнаяОбработка);

	Если СтандартнаяОбработка Тогда

		Если ХранилищеКонфигурации = Неопределено Тогда
			НастроитьХранилищеКонфигурации(ПутьКХранилищу, АвторизацияВХранилище);
		КонецЕсли;

		МассивАвторовХранилища = ХранилищеКонфигурации.ПолучитьАвторов();

		Для Каждого Автор Из МассивАвторовХранилища Цикл

			СтрокаВерсии = ТаблицаПользователей.Добавить();
			СтрокаВерсии.Автор 			= Автор;
			СтрокаВерсии.ГУИД_Автора 	= Автор;

		КонецЦикла;

	КонецЕсли;

	ОбработчикПодписок.ПослеПолученияТаблицыПользователей(ТаблицаПользователей, ПутьКХранилищу);

	Возврат ТаблицаПользователей;

КонецФункции

// Считывает из хранилища историю коммитов с привязкой к пользователям
//
Функция ПрочитатьИзХранилищаИсториюКоммитовСАвторами(Знач ПутьКХранилищу) Экспорт

	ТаблицаВерсий = ПрочитатьТаблицуИсторииХранилища(ПутьКХранилищу);
	ТаблицаПользователей = ПрочитатьТаблицуПользователейХранилища(ПутьКХранилищу);

	ДополнитьТаблицуВерсийИменамиАвторов(ТаблицаВерсий, ТаблицаПользователей);
	ТаблицаВерсий.Сортировать("НомерВерсии");

	Возврат ТаблицаВерсий;

КонецФункции

// Прописывает в таблицы пользователей и версий информацию о git auth вида user <user@email.com>
//
Процедура ДополнитьТаблицуХранилищаИнформациейОСигнатуреПользователяВГит(Знач ТаблицаХранилища, Знач КаталогРепо) Экспорт

	ПутьКФайлуСопоставления = ОбъединитьПути(КаталогРепо, ИмяФайлаАвторов());
	ТаблицаСопоставления = ПрочитатьФайлАвторовГитВТаблицуПользователей(ПутьКФайлуСопоставления);
	Для Каждого Строка Из ТаблицаХранилища Цикл

		СтрокаПользователя = ТаблицаСопоставления.Найти(строка.Автор, "Автор");
		Если СтрокаПользователя = Неопределено Тогда
			ПредставлениеАвтора =СтрШаблон("%1 <%1@%2>", строка.Автор, Строка(ДоменПочтыДляGit()));
		Иначе
			ПредставлениеАвтора = строкаПользователя.ПредставлениеАвтора;
		КонецЕсли;

		Строка.ПредставлениеАвтора = ПредставлениеАвтора;

	КонецЦикла;

КонецПроцедуры

Функция НоваяТаблицаИсторииВерсий()

	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("НомерВерсии");
	Таблица.Колонки.Добавить("ГУИД_Автора");
	Таблица.Колонки.Добавить("Автор");
	Таблица.Колонки.Добавить("Тэг");
	Таблица.Колонки.Добавить("Дата");
	Таблица.Колонки.Добавить("Комментарий");
	Таблица.Колонки.Добавить("ПредставлениеАвтора");

	Возврат Таблица;

КонецФункции

Функция НоваяТаблицаПользователейХранилища()

	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("Автор");
	Таблица.Колонки.Добавить("ГУИД_Автора");
	Таблица.Колонки.Добавить("ПредставлениеАвтора");

	Возврат Таблица;

КонецФункции

Процедура ДополнитьТаблицуВерсийИменамиАвторов(Знач ТаблицаВерсий, Знач ТаблицаПользователей)

	Для Каждого Строка Из ТаблицаВерсий Цикл
		СтрокаПользователя = ТаблицаПользователей.Найти(Строка.ГУИД_Автора, "ГУИД_Автора");
		Если СтрокаПользователя = Неопределено Тогда
			Сообщение = "Не удалось найти автора коммита из хранилища 1С по номеру версии <%1>,
			| комментарий <%2>, ГУИД-у <%3> - ПолучитьТаблицуВерсийИзФайлаХранилища1С";
			Лог.Ошибка(СтрШаблон(Сообщение, Строка.НомерВерсии, Строка.Комментарий, Строка.ГУИД_Автора));
		Иначе
			Строка.Автор = СтрокаПользователя.Автор;
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

// Генерирует файл соответствия пользователей хранилища 1С и git
//
Процедура СформироватьПервичныйФайлПользователейДляGit(Знач ПутьХранилища, Знач ВыходнойФайл) Экспорт

	резПутьКХМЛФайлуВерсийХранилища1С = "";
	резПутьКХМЛФайлуПользователейХранилища1С = "";

	Лог.Отладка("Формируем первичный файл авторов:
	| Путь к хранилищу: " + ПутьХранилища + "
	| Выходной файл: " + ВыходнойФайл);

	ТаблицаПользователейХранилища = ПрочитатьТаблицуПользователейХранилища(ПутьХранилища);

	ЗаписатьТаблицуПользователейВФайлАвторовGit(ТаблицаПользователейХранилища, ВыходнойФайл, ДоменПочтыДляGit());

КонецПроцедуры

Процедура ЗаписатьТаблицуПользователейВФайлАвторовGit(Знач ТаблицаПользователейХранилища, Знач ВыходнойФайл, Знач ДоменПочтыДляGit)

	ЗаписьФайла = Новый ЗаписьТекста(ВыходнойФайл, "utf-8");
	Попытка
		ШаблонЗаписи = "%1=%1 <%1@%2>";
		Для Каждого Запись Из ТаблицаПользователейХранилища Цикл
			СтрокаДляЗаписи = СтрШаблон(ШаблонЗаписи, Запись.Автор, ДоменПочтыДляGit);
			ЗаписьФайла.ЗаписатьСтроку(СтрокаДляЗаписи);
		КонецЦикла;

		ЗаписьФайла.Закрыть();
	Исключение
		ОсвободитьОбъект(ЗаписьФайла);
		ВызватьИсключение;
	КонецПопытки;

КонецПроцедуры

// Определяет необходимость синхронизации хранилища и репо GIT.
//
Функция ТребуетсяСинхронизироватьХранилищеСГит(Знач ФайлХранилища, Знач ЛокальныйКаталогГит) Экспорт

	ТаблицаВерсий = ПрочитатьТаблицуИсторииХранилища(ФайлХранилища);
	ТекущаяВерсия = НомерСинхронизированнойВерсии(ЛокальныйКаталогГит);
	МаксимальнаяВерсияДляРазбора = ОпределитьМаксимальнуюВерсиюВХранилище(ТаблицаВерсий);

	Лог.Информация("Номер синхронизированной версии: " + ТекущаяВерсия);
	Лог.Информация("Номер последней версии в хранилище: " + МаксимальнаяВерсияДляРазбора);

	Возврат ТекущаяВерсия < МаксимальнаяВерсияДляРазбора;

КонецФункции

//////////////////////////////////////
// СЛУЖЕБНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ

Функция НомерСинхронизированнойВерсии(Знач КаталогВыгрузки)

	ПутьФайлаВерсий = ОбъединитьПути(КаталогВыгрузки, ИмяФайлаВерсииХранилища());

	ТекущаяВерсия = ПрочитатьФайлВерсийГит(ПутьФайлаВерсий);
	Если ТекущаяВерсия <> Неопределено Тогда
		Попытка
			ТекущаяВерсия=Число(ТекущаяВерсия);
		Исключение
			ТекущаяВерсия = 0;
		КонецПопытки;
	Иначе
		ТекущаяВерсия = 0;
	КонецЕсли;

	Возврат ТекущаяВерсия;

КонецФункции

Функция ОпределитьМаксимальнуюВерсиюВХранилище(Знач ТаблицаИсторииХранилища)

	Если ТаблицаИсторииХранилища.Количество() = 0 Тогда
		Возврат 0;
	КонецЕсли;

	МаксимальнаяВерсия = Число(ТаблицаИсторииХранилища[0].НомерВерсии);
	Для Сч = 1 По ТаблицаИсторииХранилища.Количество() - 1 Цикл
		ЧислоВерсии = Число(ТаблицаИсторииХранилища[Сч].НомерВерсии);
		Если ЧислоВерсии > МаксимальнаяВерсия Тогда
			МаксимальнаяВерсия = ЧислоВерсии;
		КонецЕсли;
	КонецЦикла;

	Возврат МаксимальнаяВерсия;

КонецФункции

////////////////////////////////////////////////////////////////////////////////////////////////
// Общие функции

Функция ИмяФайлаАвторов() Экспорт
	Возврат "AUTHORS";
КонецФункции

Функция ИмяФайлаВерсииХранилища() Экспорт
	Возврат "VERSION";
КонецФункции

Процедура ЗаписатьФайлВерсийГит(Знач КаталогФайлаВерсий, Знач Версия = "") Экспорт

	ПутьКФайлуВерсий = ОбъединитьПути(КаталогФайлаВерсий, ИмяФайлаВерсииХранилища());
	Лог.Отладка("ПутьКФайлуВерсий =<"+ПутьКФайлуВерсий+">");
	Попытка
		Запись = Новый ЗаписьТекста(ПутьКФайлуВерсий, "utf-8");
		Запись.ЗаписатьСтроку("<?xml version=""1.0"" encoding=""UTF-8""?>");
		Запись.ЗаписатьСтроку("<VERSION>" + Версия + "</VERSION>");
		Запись.Закрыть();
	Исключение
		Если Запись <> Неопределено Тогда
			ОсвободитьОбъект(Запись);
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;

КонецПроцедуры

Функция ПрочитатьФайлВерсийГит(Знач ПутьКФайлуВерсий)

	Перем Версия;

	Если Не Новый Файл(ПутьКФайлуВерсий).Существует() Тогда
		ВызватьИсключение "Файл с версией ГИТ <"+ПутьКФайлуВерсий+"> не существует";
	КонецЕсли;

	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.ОткрытьФайл(ПутьКФайлуВерсий);

	Пока ЧтениеXML.Прочитать() Цикл
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента И ЧтениеXML.Имя = "VERSION" Тогда

			Если Не ЧтениеXML.Прочитать() Тогда
				ВызватьИсключение "Чтение файла версий, у элемента Version нет текста";
			КонецЕсли;

			Если Не ЧтениеXML.ТипУзла = ТипУзлаXML.Текст Тогда
				ВызватьИсключение "Чтение файла версий, у элемента Version нет текста";
			КонецЕсли;

			Версия = ЧтениеXML.Значение;
			Лог.Отладка("Предыдущая версия из хранилища 1С: " + Версия);

			лРезультат = Истина;
			Прервать;
		КонецЕсли;

	КонецЦикла;

	ЧтениеXML.Закрыть();

	Возврат Версия;

КонецФункции

Функция ПрочитатьФайлАвторовГитВТаблицуПользователей(Знач ПутьКФайлуАвторов) Экспорт

	Если НЕ ЗначениеЗаполнено(ПутьКФайлуАвторов) Тогда
		Возврат Неопределено;
	КонецЕсли;

	Файл = Новый Файл(ПутьКФайлуАвторов);
	Если Не Файл.Существует() Тогда
		Возврат НоваяТаблицаПользователейХранилища();
	КонецЕсли;

	Пользователи = НоваяТаблицаПользователейХранилища();

	Попытка
		ТекстовыйФайл = Новый ЧтениеТекста(ПутьКФайлуАвторов,"utf-8");
		СтрокаФайла = "";
		Пока СтрокаФайла <> Неопределено Цикл
			СтрокаФайла = ТекстовыйФайл.ПрочитатьСтроку();
			Индекс = Найти(СтрокаФайла, "=");
			Если Индекс > 0 Тогда

				Ключ = Лев(СтрокаФайла, Индекс-1);
				АвторПредставление = Сред(СтрокаФайла, Индекс+1);

				НоваяСтрока = Пользователи.Добавить();
				НоваяСтрока.ПредставлениеАвтора = АвторПредставление;
				НоваяСтрока.Автор = Ключ;
			КонецЕсли;
		КонецЦикла;

	Исключение
		Если ТекстовыйФайл <> Неопределено Тогда
			ОсвободитьОбъект(ТекстовыйФайл);
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;

	Если ТекстовыйФайл <> Неопределено Тогда
		ОсвободитьОбъект(ТекстовыйФайл);
	КонецЕсли;

	Возврат Пользователи;

КонецФункции


Процедура НаполнитьКаталогРабочейКопииСлужебнымиДанными(Знач КаталогРабочейКопии, Знач ПутьКХранилищу) Экспорт

	КаталогИсходников = Новый Файл(КаталогРабочейКопии);
	Если Не КаталогИсходников.Существует() Тогда

		СоздатьКаталог(КаталогИсходников.ПолноеИмя);

	ИначеЕсли Не КаталогИсходников.ЭтоКаталог() Тогда

		ВызватьИсключение "Невозможно создать каталог " + КаталогИсходников.ПолноеИмя;

	КонецЕсли;

	СгенерироватьФайлAUTHORS(ПутьКХранилищу, КаталогИсходников.ПолноеИмя);
	СгенерироватьФайлVERSION(КаталогИсходников.ПолноеИмя);

КонецПроцедуры // НаполнитьКаталогРабочейКопииСлужебнымиДанными

Процедура СгенерироватьФайлAUTHORS(Знач ПутьХранилища, Знач КаталогИсходников)

	ФайлАвторов = Новый Файл(ОбъединитьПути(КаталогИсходников, "AUTHORS"));
	Если ФайлАвторов.Существует() Тогда

		Лог.Информация("Файл " + ФайлАвторов.ПолноеИмя + " уже существует. Пропускаем генерацию файла AUTHORS");
		Возврат;

	КонецЕсли;

	Попытка

		Лог.Отладка("Формирую файл AUTHORS в каталоге " + КаталогИсходников);
		СформироватьПервичныйФайлПользователейДляGit(ПутьХранилища, ФайлАвторов.ПолноеИмя);
		Лог.Отладка("Файл сгенерирован");

	Исключение

		Лог.Ошибка("Не удалось сформировать файл авторов");
		ВызватьИсключение;

	КонецПопытки;

КонецПроцедуры // СгенерироватьФайлAUTHORS

Процедура СгенерироватьФайлVERSION(Знач КаталогИсходников)

	ФайлВерсий = Новый Файл(ОбъединитьПути(КаталогИсходников, "VERSION"));
	Если ФайлВерсий.Существует() Тогда

		Лог.Информация("Файл " + ФайлВерсий.ПолноеИмя + " уже существует. Пропускаем генерацию файла VERSION");
		Возврат;

	КонецЕсли;

	ЗаписатьФайлВерсийГит(ФайлВерсий.Путь);

КонецПроцедуры // СгенерироватьФайлVERSION

///////////////////////////////////////////////////////////////////////////////////////////////
// Вспомогательные функции

// Удаляет временные файлы при необходимости
// Если передана пустая строка, то удаляются все зарегистрированные временные файлы
//
// Параметры:
//   ПутьКФайлу - Строка - полный путь файла или пустая строка
//
Процедура УдалитьВременныеФайлыПриНеобходимости(Знач ПутьКФайлу = "")

	Если УдалятьВременныеФайлы Тогда
		Возврат;
	КонецЕсли;

	Если ПутьКФайлу = "" Тогда
		ВременныеФайлы.Удалить();
	Иначе
		ВременныеФайлы.УдалитьФайл(ПутьКФайлу);
	КонецЕсли;

КонецПроцедуры

Процедура УстановитьОбработчикПодписок(НовыйОбработчикПодписок)

	ОбработчикПодписок = НовыйОбработчикПодписок;

	ОбработчикПодписок.ПриАктивизации(ЭтотОбъект);

КонецПроцедуры

Функция ИмяЛога()

	Возврат "oscript.lib.gitsync";

КонецФункции

Процедура ПриСозданииОбъекта(ВходящийОбработчикПодписок = Неопределено)

	Если ВходящийОбработчикПодписок = Неопределено Тогда
		ПустойОбработчик = Новый МенеджерПодписок(Новый Соответствие);
		УстановитьОбработчикПодписок(ПустойОбработчик);
	Иначе
		УстановитьОбработчикПодписок(ВходящийОбработчикПодписок);
	КонецЕсли;

	Лог = Логирование.ПолучитьЛог(ИмяЛога());

	УдалятьВременныеФайлы = Ложь;
	МинимальнаяРазницаМеждуКоммитамиНовогоХранилища = 10;
	АвторизацияВХранилище = Новый Структура("ПользовательХранилища, ПарольХранилища");

	КоличествоЦикловОжиданияЛицензииПоУмолчанию = 3;

	СистемнаяИнформация = Новый СистемнаяИнформация;
	ЭтоWindows = Найти(НРег(СистемнаяИнформация.ВерсияОС), "windows") > 0;

	ВерсияПлатформы = "8.3";

КонецПроцедуры

Функция ДатаPOSIX(Знач Дата)

	Возврат "" + Год(Дата) + "-" + ФорматДвузначноеЧисло(Месяц(Дата)) + "-" + ФорматДвузначноеЧисло(День(Дата)) + " "
			+ ФорматДвузначноеЧисло(Час(Дата)) + ":" + ФорматДвузначноеЧисло(Минута(Дата))
			+ ":" + ФорматДвузначноеЧисло(Секунда(Дата));

КонецФункции

Функция ЗапуститьПриложениеИДождатьсяЗавершения(Знач СтрокаЗапуска, Знач ТекущийКаталог = "\.")

	рез = -1;
	Если НЕ ЭтоWindows И ТекущийКаталог = "\." Тогда
		ТекущийКаталог = "./";
	КонецЕсли;

	Попытка
		КодВозврата = "";
		ЗапуститьПриложение(СтрокаЗапуска, ТекущийКаталог, Истина, КодВозврата);
		рез = КодВозврата;
	Исключение
		// Для x64 ОС
		Если ЭтоWindows Тогда
			СтрокаЗапуска = "%windir%\Sysnative\" + СтрокаЗапуска;
			КодВозврата = "";
			ЗапуститьПриложение(СтрокаЗапуска, ТекущийКаталог, Истина, КодВозврата);
			рез = КодВозврата;
		КонецЕсли;
	КонецПопытки;

	Возврат рез;

КонецФункции // ЗапуститьПриложениеИДождатьсяЗавершения()

Процедура ЗавершитьПроцесс_TGitCache_exe()
	Если ЭтоWindows Тогда
		СтрокаКоманды = "taskkill /im TGitCache.exe  /T /F";
		Лог.Отладка("ЗавершитьПроцесс_TGitCache_exe: команда "+ СтрокаКоманды);

		ЗапуститьПриложениеИДождатьсяЗавершения(СтрокаКоманды);
	КонецЕсли;
КонецПроцедуры

Функция ФорматДвузначноеЧисло(ЗначениеЧисло)
	ЧислоСтрокой = Строка(ЗначениеЧисло);
	Если СтрДлина(ЧислоСтрокой) < 2 Тогда
		ЧислоСтрокой = "0" + ЧислоСтрокой;
	КонецЕсли;

	Возврат ЧислоСтрокой;
КонецФункции

Функция ДоменПочтыДляGit()
	Возврат ?(ДоменПочтыДляGitПоУмолчанию = Неопределено, "localhost", ДоменПочтыДляGitПоУмолчанию);
КонецФункции

Функция ПолучитьКоличествоЦикловОжиданияЛицензииПоУмолчанию() Экспорт
	Возврат КоличествоЦикловОжиданияЛицензииПоУмолчанию;
КонецФункции


