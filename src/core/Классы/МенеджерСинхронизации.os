///////////////////////////////////////////////////////////////////////////////////////////////
//
// Модуль основан на проекте v83unpack (https://github.com/xDrivenDevelopment/v83unpack)
// и является скорее глубоким рефакторингом под 1Script, нежели самостоятельной разработкой.
//
// Использует также утилиту Tool_1CD от awa (http://infostart.ru/public/19633/)
//
///////////////////////////////////////////////////////////////////////////////////////////////

#Использовать logos
#Использовать tempfiles
#Использовать v8runner
#Использовать v8storage
#Использовать strings
#Использовать 1commands
#Использовать gitrunner
#Использовать fs

Перем Лог;
Перем мФайлПрограммыРаспаковки;
Перем ЭтоWindows;
Перем УдалятьВременныеФайлы;
Перем КоличествоЦикловОжиданияЛицензииПоУмолчанию;

Перем РабочийКаталогСохр;
Перем ГитРепозиторийСохр;
// Определяем мин количество коммитов между разницей версии уже в git и в хранилище
// для случаев, когда пересоздали хранилище и в гите находится версия 1234, а в хранилище 4,
// тогда вызываем исключение если разница в коммитах больше чем на эту велечину. 
Перем МинимальнаяРазницаМеждуКоммитамиНовогоХранилища;
Перем Плагины;
Перем НастройкиПриложения;

Перем ХранилищеКонфигурации;
Перем АвторизацияВХранилище;

///////////////////////////////////////////////////////////////////////////////////////////////
// ПРОГРАММНЫЙ ИНТЕРФЕЙС

Перем ДоменПочтыДляGitПоУмолчанию Экспорт;
Перем ВерсияПлатформы Экспорт;

// Основная функция синхронизации. 
// Перемещает в git набор коммитов хранилища 1С
//
Процедура СинхронизироватьХранилищеКонфигурацийСГит(Знач КаталогРабочейКопии, 
													Знач ПутьКХранилищу, 
													Знач Формат = Неопределено, 
													Знач URLРепозитория = Неопределено,
													Знач ИмяВетки = Неопределено) Экспорт

	Плагины.ПередНачаломВыполнения(ПутьКХранилищу, КаталогРабочейКопии, URLРепозитория, ИмяВетки);

	Лог.Информация("Начало синхронизации с git");
	Лог.Отладка("Используется формат выгрузки " + Формат);
	
	НастроитьХранилищеКонфигурации(ПутьКХранилищу, АвторизацияВХранилище);

	ТаблицаИсторииХранилища = ПрочитатьИзХранилищаИсториюКоммитовСАвторами(ПутьКХранилищу);

	ДополнитьТаблицуХранилищаИнформациейОСигнатуреПользователяВГит(ТаблицаИсторииХранилища, КаталогРабочейКопии);

	ТекущаяВерсия = НомерСинхронизированнойВерсии(КаталогРабочейКопии);

	Лог.Информация("Номер синхронизированной версии: " + ТекущаяВерсия);
	СледующаяВерсия = ТекущаяВерсия + 1;

	МаксимальнаяВерсияДляРазбора = ОпределитьМаксимальнуюВерсиюВХранилище(ТаблицаИсторииХранилища);
	Лог.Информация("Номер последней версии в хранилище: " + МаксимальнаяВерсияДляРазбора);
		
	Если СледующаяВерсия > МаксимальнаяВерсияДляРазбора И СледующаяВерсия - МаксимальнаяВерсияДляРазбора > МинимальнаяРазницаМеждуКоммитамиНовогоХранилища Тогда
		Лог.Ошибка("Несоответствие версий хранилища 1С и версию в репозитории Git. 
		|Возможно, сократили/обрезали хранилище. 
		|Для продолжения синхронизации измените файл VERSIONS в корне репозитория Git, 
		|Исправьте версию %1 на правильную версию <= версии в хранилище %2", ТекущаяВерсия, МаксимальнаяВерсияДляРазбора);
		
		ВызватьИсключение СтрШаблон("Версия git %1 больше версии хранилища %2 на %3", ТекущаяВерсия, МаксимальнаяВерсияДляРазбора, СледующаяВерсия - МаксимальнаяВерсияДляРазбора); 
	КонецЕсли;

	Плагины.ПередНачаломЦиклаОбработкиВерсий(ТаблицаИсторииХранилища, ТекущаяВерсия, СледующаяВерсия, МаксимальнаяВерсияДляРазбора);

	Пока СледующаяВерсия <= МаксимальнаяВерсияДляРазбора Цикл
				
		СтрокаВерсии = ТаблицаИсторииХранилища.Найти(СледующаяВерсия, "НомерВерсии");
		Если СтрокаВерсии <> Неопределено Тогда

			Плагины.ПередОбработкойВерсииХранилища(СтрокаВерсии, СледующаяВерсия);

			Попытка
				Лог.Информация("Получаем исходники для версии " + СледующаяВерсия + ", " + ТекущаяДата());
				
				Плагины.ПриОбработкеВерсииХранилища(СтрокаВерсии, СледующаяВерсия);
				ВыгрузитьВерсиюХранилищаКонфигурацииВИсходники(КаталогРабочейКопии, ПутьКХранилищу, СледующаяВерсия, Формат);

				Лог.Отладка("Фиксируем в файле VERSION версию " + СледующаяВерсия);
				ЗаписатьФайлВерсийГит(КаталогРабочейКопии, СледующаяВерсия);
				ВыполнитьКоммитГит(КаталогРабочейКопии, СтрокаВерсии.Комментарий, СтрокаВерсии.ПредставлениеАвтора, СтрокаВерсии.Дата);


			Исключение
				Лог.Отладка("Откатываем файл VERSION после ошибки");
				ЗаписатьФайлВерсийГит(КаталогРабочейКопии, ТекущаяВерсия);
				ВызватьИсключение;
			КонецПопытки;

			ТекущаяВерсия = СледующаяВерсия;
			Плагины.ПослеОбработкиВерсииХранилища(СтрокаВерсии, ТекущаяВерсия);
		
		КонецЕсли;

		СледующаяВерсия = СледующаяВерсия + 1;

	КонецЦикла;

	ЗавершитьПроцесс_TGitCache_exe();
	
	Плагины.ПослеОкончанияВыполнения(ПутьКХранилищу, КаталогРабочейКопии, URLРепозитория, ИмяВетки);
	
	УдалитьВременныеФайлыПриНеобходимости();

КонецПроцедуры

#Область ОБРАБОТКА ВЕРСИИ КОНФИГУРАЦИИ

////////////////////////////////
// ОБРАБОТКА ВЕРСИИ КОНФИГУРАЦИИ

Процедура ВыгрузитьВерсиюХранилищаКонфигурацииВИсходники(Знач КаталогРабочейКопии, Знач ПутьКХранилищу, Знач НомерВерсии, Знач Формат) Экспорт
	
	Конфигуратор = ПолучитьМенеджерКонфигуратора();

	Плагины.ПередНачаломВыгрузкиВерсииХранилищаКонфигурации(Конфигуратор, КаталогРабочейКопии, ПутьКХранилищу, НомерВерсии, Формат);
	
	Плагины.ПередЗагрузкойВерсииХранилищаКонфигурации(Конфигуратор, КаталогРабочейКопии, ПутьКХранилищу, НомерВерсии, Формат);
	ЗагрузитьВерсиюХранилищаВКонфигурацию(Конфигуратор, КаталогРабочейКопии, ПутьКХранилищу, НомерВерсии);

	КаталогВыгрузки = ВременныеФайлы.СоздатьКаталог();
	
	Лог.Отладка("Каталог выгрузки <%1> для версии <%2>", КаталогВыгрузки , НомерВерсии);

	Плагины.ПередВыгрузкойКонфигурациюВИсходники(Конфигуратор, КаталогРабочейКопии, КаталогВыгрузки, ПутьКХранилищу, НомерВерсии, Формат);
	ВыгрузитьКонфигурациюВИсходники(Конфигуратор, КаталогВыгрузки, Формат);

	Плагины.ПередОчисткойКаталогаРабочейКопии(Конфигуратор, КаталогРабочейКопии, КаталогВыгрузки, ПутьКХранилищу, НомерВерсии, Формат);
	ОчиститьКаталогРабочейКопии(КаталогРабочейКопии);
	
	Плагины.ПередПеремещениемВКаталогРабочейКопии(Конфигуратор, КаталогРабочейКопии, КаталогВыгрузки, ПутьКХранилищу, НомерВерсии, Формат);
	ПереместитьВКаталогРабочейКопии(КаталогРабочейКопии, КаталогВыгрузки, Формат);
	
	Плагины.ПослеОкончанияВыгрузкиВерсииХранилищаКонфигурации(Конфигуратор, КаталогРабочейКопии, ПутьКХранилищу, НомерВерсии, Формат);
	
	УдалитьВременныеФайлыПриНеобходимости(Конфигуратор.КаталогСборки());
	УдалитьВременныеФайлыПриНеобходимости(КаталогВыгрузки);

КонецПроцедуры

Процедура ЗагрузитьВерсиюХранилищаВКонфигурацию(Знач Конфигуратор, Знач КаталогРабочейКопии, Знач ПутьКХранилищу, Знач НомерВерсии) Экспорт
	СтандартнаяОбработка = Истина;

	Плагины.ПриЗагрузкеВерсииХранилищаВКонфигурацию(Конфигуратор, КаталогРабочейКопии, ПутьКХранилищу, НомерВерсии, СтандартнаяОбработка);
	
	Если СтандартнаяОбработка Тогда
		
		ХранилищеКонфигурации.УстановитьУправлениеКонфигуратором(Конфигуратор);
		
		КоличествоЦикловОжиданияЛицензии = ПолучитьКоличествоЦикловОжиданияЛицензииПоУмолчанию();
			
		Пока КоличествоЦикловОжиданияЛицензии >= 0 Цикл
			Попытка
				
				ХранилищеКонфигурации.ОбновитьКонфигурациюНаВерсию(НомерВерсии);
				Прервать;
	
			Исключение
				// проверим текст ошибки, если текст содержит информацию о необходимости конвертировать
				// тогда выполним конвертацию и повторно попытаемся загрузить файл
				ТекстОшибки = ВРег(ХранилищеКонфигурации.ПолучитьВыводКоманды());
				Если Найти(ТекстОшибки, Врег("Не обнаружено свободной лицензии!")) Тогда
					Лог.Ошибка(ТекстОшибки);
					Лог.Информация("Повторное подключение через 10сек. Осталось попыток: " + КоличествоЦикловОжиданияЛицензии);
					Приостановить(10000);
	
				Иначе
					
					ВызватьИсключение ТекстОшибки;
					
				КонецЕсли;
				
			КонецПопытки;
	
			Если ПолучитьКоличествоЦикловОжиданияЛицензииПоУмолчанию() <> 0 Тогда
				КоличествоЦикловОжиданияЛицензии = КоличествоЦикловОжиданияЛицензии - 1;
			КонецЕсли;
			
		КонецЦикла;

	КонецЕсли;

	Плагины.ПослеЗагрузкиВерсииХранилищаВКонфигурацию(Конфигуратор, КаталогРабочейКопии, ПутьКХранилищу, НомерВерсии);

КонецПроцедуры

Процедура ВыгрузитьКонфигурациюВИсходники(Знач Конфигуратор, Знач КаталогВыгрузки, Знач Формат) Экспорт
	
	СтандартнаяОбработка = Истина;

	Плагины.ПриВыгрузкеКонфигурациюВИсходники(Конфигуратор, КаталогВыгрузки, Формат, СтандартнаяОбработка);
	
	Если СтандартнаяОбработка Тогда
		
		Конфигуратор.ВыгрузитьКонфигурациюВФайлы(КаталогВыгрузки, Формат);
		
	КонецЕсли;
	
	Плагины.ПослеВыгрузкиКонфигурациюВИсходники(Конфигуратор, КаталогВыгрузки,  Формат);
	
КонецПроцедуры

Процедура ОчиститьКаталогРабочейКопии(Знач КаталогРабочейКопии) Экспорт
	
	СтандартнаяОбработка = Истина;

	СоответствиеИменФайловДляПропуска = Новый Соответствие;
	СоответствиеИменФайловДляПропуска.Вставить(".git", Истина);
	СоответствиеИменФайловДляПропуска.Вставить(ИмяФайлаАвторов(), Истина); //Соответствие авторов и транслитерации.
	СоответствиеИменФайловДляПропуска.Вставить(ИмяФайлаВерсииХранилища(), Истина); //Номер версии, может использоватся для синхронизации с хранилищем.

	Плагины.ПриОчисткеКаталогаРабочейКопии(КаталогРабочейКопии, СоответствиеИменФайловДляПропуска, СтандартнаяОбработка);
	
	Если СтандартнаяОбработка Тогда
	
		//Удалим все каталоги с файлами в папке для разбора, кроме папки, начинающейся с с точки.
		ЕстьОшибкаУдаления = Ложь;
		Для НомерПопытки = 1 По 2 Цикл
			МассивФайлов = НайтиФайлы(КаталогРабочейКопии, ПолучитьМаскуВсеФайлы());
			Если МассивФайлов.Количество() = 0 Тогда
				Прервать;
			КонецЕсли;
	
			Для Каждого ЭлементМассива Из МассивФайлов Цикл
				Если СоответствиеИменФайловДляПропуска[ЭлементМассива.Имя] = Истина Тогда
					Продолжить;
				КонецЕсли;
	
				Попытка
					УдалитьФайлы(ЭлементМассива.ПолноеИмя);
				Исключение
					ЕстьОшибкаУдаления = Истина;
					Если НомерПопытки = 2 Тогда
						ВызватьИсключение;
					КонецЕсли;
				КонецПопытки;
			КонецЦикла;
	
			Если Не ЕстьОшибкаУдаления Тогда
				Прервать;
			КонецЕсли;
	
		КонецЦикла;
		
	КонецЕсли;
	
	Плагины.ПослеОчисткиКаталогаРабочейКопии(КаталогРабочейКопии, СоответствиеИменФайловДляПропуска);
	
КонецПроцедуры

Процедура ПереместитьВКаталогРабочейКопии(Знач КаталогРабочейКопии, Знач КаталогВыгрузки, Знач Формат) Экспорт
	
	СтандартнаяОбработка = Истина;

	ТаблицаПереименования = Новый ТаблицаЗначений;
	ТаблицаПереименования.Колонки.Добавить("Источник");
	ТаблицаПереименования.Колонки.Добавить("Приемник");

	ПутьКФайлуПереименования = ОбъединитьПути(КаталогРабочейКопии, "renames.txt");

	Плагины.ПриПеремещенииВКаталогРабочейКопии(КаталогРабочейКопии, КаталогВыгрузки, ТаблицаПереименования, ПутьКФайлуПереименования, СтандартнаяОбработка);
	
	Если СтандартнаяОбработка Тогда
			
		СписокФайлов = НайтиФайлы(КаталогВыгрузки, ПолучитьМаскуВсеФайлы(), Истина);
		Лог.Отладка("Найдено файлов выгрузки: %1 шт.",СписокФайлов.Количество());
		Лог.Отладка("КаталогРабочейКопии: %1 ", КаталогРабочейКопии);
		Для Каждого Файл Из СписокФайлов Цикл
			
			КорневойКаталог = КаталогВыгрузки;
			Если НЕ СтрЗаканчиваетсяНа(КорневойКаталог, ПолучитьРазделительПути()) Тогда
				КорневойКаталог = КорневойКаталог + ПолучитьРазделительПути();
			КонецЕсли;
			
			ИмяНовогоФайла = СтрЗаменить(Файл.ПолноеИмя, КорневойКаталог, "");
		
			Если Файл.ЭтоКаталог() Тогда
				
				ИмяКаталога = ОбъединитьПути(КаталогРабочейКопии, ИмяНовогоФайла);
				Лог.Отладка("Обрабатываю ИмяКаталога: %1 ", ИмяКаталога);	
				ФайлКаталога = Новый Файл(ИмяКаталога);
				Если НЕ ФайлКаталога.Существует() Тогда
					СоздатьКаталог(ФайлКаталога.ПолноеИмя);
				КонецЕсли;
				
				Продолжить;

			КонецЕсли;
	
			НовыйФайл = Новый Файл(ОбъединитьПути(КаталогРабочейКопии, ИмяНовогоФайла));
			НовыйКаталог = Новый Файл(НовыйФайл.Путь);
			Если НЕ НовыйКаталог.Существует() Тогда
				СоздатьКаталог(НовыйКаталог.ПолноеИмя);
			КонецЕсли;
	
			КопироватьФайл(Файл.ПолноеИмя, НовыйФайл.ПолноеИмя);
	
		КонецЦикла;
	
	КонецЕсли;
	
	Плагины.ПослеПеремещенияВКаталогРабочейКопии(КаталогРабочейКопии, КаталогВыгрузки, ТаблицаПереименования, ПутьКФайлуПереименования);

КонецПроцедуры

#КонецОбласти

#Область РАБОТА С КОНФИГУРАТОРОМ 

Функция ПолучитьМенеджерКонфигуратора() Экспорт
	Конфигуратор = Новый УправлениеКонфигуратором;
	Логирование.ПолучитьЛог("oscript.lib.v8runner").УстановитьУровень(Лог.Уровень());
	КаталогСборки = ВременныеФайлы.СоздатьКаталог();
	Конфигуратор.КаталогСборки(КаталогСборки);

	Если ВерсияПлатформы <> Неопределено Тогда
		Конфигуратор.ИспользоватьВерсиюПлатформы(ВерсияПлатформы);
	Иначе
		Конфигуратор.ИспользоватьВерсиюПлатформы("8.3");
	КонецЕсли;

	Возврат Конфигуратор;
КонецФункции

Процедура УстановитьАвторизациюВХранилищеКонфигурации(Знач Логин, Знач Пароль) Экспорт

	Лог.Отладка("Установлена авторизация в хранилище пользователь <%1>, пароль <%2>", Логин, Пароль);
	АвторизацияВХранилище.Вставить("ПользовательХранилища" , Логин);
	АвторизацияВХранилище.Вставить("ПарольХранилища", Пароль);

КонецПроцедуры

Процедура НастроитьХранилищеКонфигурации(Знач ПутьКХранилищу, Знач ПараметрыАвторизацииВХранилище)

	Если ХранилищеКонфигурации = Неопределено Тогда	
		ХранилищеКонфигурации = Новый МенеджерХранилищаКонфигурации;
		Конфигуратор = ХранилищеКонфигурации.ПолучитьУправлениеКонфигуратором();

		Если ВерсияПлатформы <> Неопределено Тогда
			Конфигуратор.ИспользоватьВерсиюПлатформы(ВерсияПлатформы);
		Иначе
			Конфигуратор.ИспользоватьВерсиюПлатформы("8.3");
		КонецЕсли;

	КонецЕсли;

	Логирование.ПолучитьЛог("oscript.lib.v8storage").УстановитьУровень(Лог.Уровень());
	ПроверитьПараметрыДоступаКХранилищу();
	ХранилищеКонфигурации.УстановитьПараметрыАвторизации(ПараметрыАвторизацииВХранилище.ПользовательХранилища, ПараметрыАвторизацииВХранилище.ПарольХранилища);
	ХранилищеКонфигурации.УстановитьПутьКХранилищу(ПутьКХранилищу);

КонецПроцедуры

Процедура ПроверитьПараметрыДоступаКХранилищу() Экспорт

	Если АвторизацияВХранилище.ПользовательХранилища = Неопределено 
		ИЛИ ПустаяСтрока(АвторизацияВХранилище.ПользовательХранилища) Тогда

		ВызватьИсключение "Не задан пользователь хранилища конфигурации.";

	КонецЕсли;

	Если АвторизацияВХранилище.ПарольХранилища = Неопределено Тогда

		ПарольХранилища = "";

	КонецЕсли;

КонецПроцедуры // ПроверитьПараметрыДоступаКХранилищу

#КонецОбласти

#Область РАБОТА С GIT

/////////////////////////////////////
// GIT Пересмотр

Функция ПолучитьГитРепозиторий(Знач КаталогРабочейКопии) Экспорт
	
	ФайлКаталога = Новый Файл(КаталогРабочейКопии);
	Если ФайлКаталога.ПолноеИмя = РабочийКаталогСохр Тогда
		ГитРепозиторий = ГитРепозиторийСохр;
	Иначе
		ГитРепозиторий = Новый ГитРепозиторий;
		ГитРепозиторий.УстановитьРабочийКаталог(КаталогРабочейКопии);
		ГитРепозиторий.УстановитьТихийРежимРаботы();
		
		ГитРепозиторий.УстановитьНастройку("core.quotepath", "false", РежимУстановкиНастроекGit.Локально);
		ГитРепозиторий.УстановитьНастройку("merge.ours.driver", "true", РежимУстановкиНастроекGit.Локально);

		ГитРепозиторий.УстановитьНормальныйРежимРаботы();
		
		РабочийКаталогСохр = ФайлКаталога.ПолноеИмя;
		ГитРепозиторийСохр = ГитРепозиторий;

	КонецЕсли;

	Возврат ГитРепозиторий;

КонецФункции // ПолучитьГитРепозиторий()


// Выполняет фиксацию изменений в локальном каталоге git
//
Процедура ВыполнитьКоммитГит(Знач КаталогРабочейКопии, Знач Комментарий, Знач Автор, Знач Дата = Неопределено) Экспорт

	Плагины.ПередКоммитом(КаталогРабочейКопии, Комментарий, Автор, Дата);

	Если Дата = Неопределено Тогда
		Дата = ТекущаяДата();
	КонецЕсли;

	авторДляГит = Автор;
	
	Лог.Отладка("Автор коммита: %1", авторДляГит);
	ДатаДляГит = ДатаPOSIX(Дата);
	Лог.Отладка("Дата коммита: %1", ДатаДляГит);
	ИмяФайлаКомментария = ПодготовитьФайлКоммита(Комментарий);
	
	ГитРепозиторий = ПолучитьГитРепозиторий(КаталогРабочейКопии);
	ПроиндексироватьОтслеживаемыеФайлы = Истина;
	// Выполнение индексации всех измененных файлов
	Плагины.ПриКоммите(ГитРепозиторий, 
				Комментарий, 
				ПроиндексироватьОтслеживаемыеФайлы, 
				ИмяФайлаКомментария, 
				авторДляГит,
				ДатаДляГит,
				авторДляГит,
				ДатаДляГит);
	
	ГитРепозиторий.ВыполнитьКоманду(СтрРазделить("add -A .", " "));
	ГитРепозиторий.Закоммитить(Комментарий,
								ПроиндексироватьОтслеживаемыеФайлы,
								ИмяФайлаКомментария,
								авторДляГит,
								ДатаДляГит,
								авторДляГит,
								ДатаДляГит);
	Лог.Отладка("Вывод команды Commit: %1", СокрЛП(ГитРепозиторий.ПолучитьВыводКоманды()));
	
	Плагины.ПослеКоммита(ГитРепозиторий, КаталогРабочейКопии);
		
	ЗавершитьПроцесс_TGitCache_exe();

КонецПроцедуры

Функция ПодготовитьФайлКоммита(Знач Комментарий)
	
	ИмяФайлаКомментария = ВременныеФайлы.СоздатьФайл("txt");
	ФайлКомментария = Новый ЗаписьТекста(ИмяФайлаКомментария, КодировкаТекста.UTF8NoBOM);
	ФайлКомментария.Записать(?(ПустаяСтрока(Комментарий), ".", Комментарий));
	ФайлКомментария.Закрыть();
	Лог.Отладка(СтрШаблон("Текст коммита: %1", Комментарий));

	Возврат ИмяФайлаКомментария;

КонецФункции

#КонецОбласти

//////////////////////////////////////////////////////////////////////////
// Работа с таблицами хранилища 1С

// Выполняет чтение таблицы VERSIONS из хранилища 1С
//
// Возвращаемое значение: ТаблицаЗначений
//
Функция ПрочитатьТаблицуИсторииХранилища(Знач ПутьКХранилищу) Экспорт

	СтандартнаяОбработка = Истина;

	ТаблицаВерсий = НоваяТаблицаИсторииВерсий();
	
	Плагины.ПриПолученииТаблицыВерсий(ТаблицаВерсий, ПутьКХранилищу, СтандартнаяОбработка);
	
	Если СтандартнаяОбработка Тогда
		
		Лог.Отладка("Получение таблицы версий средствами 1С.Предприятие");
		Если ХранилищеКонфигурации = Неопределено Тогда
			НастроитьХранилищеКонфигурации(ПутьКХранилищу, АвторизацияВХранилище);
		КонецЕсли;
		  
		ТаблицаВерсийХранилища = ХранилищеКонфигурации.ПолучитьТаблицуВерсий();
	
		Для Каждого СтрокаВерсииХранилища Из ТаблицаВерсийХранилища Цикл

			СтрокаВерсии = ТаблицаВерсий.Добавить();
			СтрокаВерсии.НомерВерсии	= СтроковыеФункции.СтрокаВЧисло(СтрЗаменить(СтрокаВерсииХранилища.Номер, " ", ""));
			СтрокаВерсии.Автор 			= СтрокаВерсииХранилища.Автор;
			СтрокаВерсии.ГУИД_Автора 	= СтрокаВерсииХранилища.Автор;
			СтрокаВерсии.Дата 			= СтрокаВерсииХранилища.Дата;
			СтрокаВерсии.Комментарий 	= СтрокаВерсииХранилища.Комментарий;
			СтрокаВерсии.Тэг 			= ""; // теги в отчете не предоставляются

			СтрокаШаблонаЛога = "Добавили строку в таблицу версий:
			| Номер версии: %1
			| Автор:        %2
			| ГУИД_Автора:  %3
			| Дата:         %4
			| Комментарий:  %5
			|";
			Лог.Отладка(СтрокаШаблонаЛога, СтрокаВерсии.НомерВерсии,
										СтрокаВерсии.Автор,
										СтрокаВерсии.ГУИД_Автора,
										СтрокаВерсии.Дата,
										СтрокаВерсии.Комментарий);

		КонецЦикла;

	КонецЕсли;

	ТаблицаВерсий.Сортировать("НомерВерсии");

	Плагины.ПослеПолученияТаблицыВерсий(ТаблицаВерсий, ПутьКХранилищу);
	
	Возврат ТаблицаВерсий;

КонецФункции

// Считывает таблицу USERS пользователей хранилища
//
Функция ПрочитатьТаблицуПользователейХранилища(Знач ПутьКХранилищу) Экспорт

	СтандартнаяОбработка = Истина;

	ТаблицаПользователей = НоваяТаблицаПользователейХранилища();
	
	Плагины.ПриПолученииТаблицыПользователей(ТаблицаПользователей, ПутьКХранилищу, СтандартнаяОбработка);
	
	Если СтандартнаяОбработка Тогда
	
		Если ХранилищеКонфигурации = Неопределено Тогда
			НастроитьХранилищеКонфигурации(ПутьКХранилищу, АвторизацияВХранилище);
		КонецЕсли;

		МассивАвторовХранилища = ХранилищеКонфигурации.ПолучитьАвторов();
	
		Для Каждого Автор Из МассивАвторовХранилища Цикл
	
			СтрокаВерсии = ТаблицаПользователей.Добавить();
			СтрокаВерсии.Автор 			= Автор;
			СтрокаВерсии.ГУИД_Автора 	= Автор;
	
		КонецЦикла;

	КонеЦесли;

	Плагины.ПослеПолученияТаблицыПользователей(ТаблицаПользователей, ПутьКХранилищу);
	
	Возврат ТаблицаПользователей;

КонецФункции

// Считывает из хранилища историю коммитов с привязкой к пользователям
//
Функция ПрочитатьИзХранилищаИсториюКоммитовСАвторами(Знач ПутьКХранилищу) Экспорт
	
	ТаблицаВерсий = ПрочитатьТаблицуИсторииХранилища(ПутьКХранилищу);
	ТаблицаПользователей = ПрочитатьТаблицуПользователейХранилища(ПутьКХранилищу);

	ДополнитьТаблицуВерсийИменамиАвторов(ТаблицаВерсий, ТаблицаПользователей);
	ТаблицаВерсий.Сортировать("НомерВерсии");

	Возврат ТаблицаВерсий;

КонецФункции

// Прописывает в таблицы пользователей и версий информацию о git auth вида user <user@email.com>
//
Процедура ДополнитьТаблицуХранилищаИнформациейОСигнатуреПользователяВГит(Знач ТаблицаХранилища, Знач КаталогРепо) Экспорт

	ПутьКФайлуСопоставления = ОбъединитьПути(КаталогРепо, ИмяФайлаАвторов());
	ТаблицаСопоставления = ПрочитатьФайлАвторовГитВТаблицуПользователей(ПутьКФайлуСопоставления);
	Для Каждого Строка Из ТаблицаХранилища Цикл

		СтрокаПользователя = ТаблицаСопоставления.Найти(строка.Автор, "Автор");
		Если СтрокаПользователя = Неопределено Тогда
			ПредставлениеАвтора = СтроковыеФункции.ПодставитьПараметрыВСтроку("%1 <%1@%2>", строка.Автор, Строка(ДоменПочтыДляGit()));
		Иначе
			ПредставлениеАвтора = строкаПользователя.ПредставлениеАвтора;
		КонецЕсли;

		Строка.ПредставлениеАвтора = ПредставлениеАвтора;

	КонецЦикла;

КонецПроцедуры

Функция НоваяТаблицаИсторииВерсий()

	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("НомерВерсии");
	Таблица.Колонки.Добавить("ГУИД_Автора");
	Таблица.Колонки.Добавить("Автор");
	Таблица.Колонки.Добавить("Тэг");
	Таблица.Колонки.Добавить("Дата");
	Таблица.Колонки.Добавить("Комментарий");
	Таблица.Колонки.Добавить("ПредставлениеАвтора");

	Возврат Таблица;

КонецФункции

Функция НоваяТаблицаПользователейХранилища()

	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("Автор");
	Таблица.Колонки.Добавить("ГУИД_Автора");
	Таблица.Колонки.Добавить("ПредставлениеАвтора");

	Возврат Таблица;

КонецФункции

Процедура ДополнитьТаблицуВерсийИменамиАвторов(Знач ТаблицаВерсий, Знач ТаблицаПользователей)

	Для Каждого Строка Из ТаблицаВерсий Цикл
		строкаПользователя = ТаблицаПользователей.Найти(Строка.ГУИД_Автора, "ГУИД_Автора");
		Если строкаПользователя = Неопределено Тогда
			Сообщение = "Не удалось найти автора коммита из хранилища 1С по номеру версии <%1>, комментарий <%2>, ГУИД-у <%3> - ПолучитьТаблицуВерсийИзФайлаХранилища1С";
			Лог.Ошибка(СтроковыеФункции.ПодставитьПараметрыВСтроку(Сообщение, строка.НомерВерсии, строка.Комментарий, строка.ГУИД_Автора));
		Иначе
			строка.Автор = строкаПользователя.Автор;
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

// Генерирует файл соответствия пользователей хранилища 1С и git
//
Процедура СформироватьПервичныйФайлПользователейДляGit(Знач ПутьХранилища, Знач ВыходнойФайл) Экспорт

	резПутьКХМЛФайлуВерсийХранилища1С = "";
	резПутьКХМЛФайлуПользователейХранилища1С = "";

	Лог.Отладка("Формируем первичный файл авторов:
	| Путь к хранилищу: " + ПутьХранилища + "
	| Выходной файл: " + ВыходнойФайл);

	ТаблицаПользователейХранилища = ПрочитатьТаблицуПользователейХранилища(ПутьХранилища);

	ЗаписатьТаблицуПользователейВФайлАвторовGit(ТаблицаПользователейХранилища, ВыходнойФайл, ДоменПочтыДляGit());

КонецПроцедуры

Процедура ЗаписатьТаблицуПользователейВФайлАвторовGit(Знач ТаблицаПользователейХранилища, Знач ВыходнойФайл, Знач ДоменПочтыДляGit)

	ЗаписьФайла = Новый ЗаписьТекста(ВыходнойФайл, "utf-8");
	Попытка
		ШаблонЗаписи = "%1=%1 <%1@%2>";
		Для Каждого Запись Из ТаблицаПользователейХранилища Цикл
			СтрокаДляЗаписи = СтрШаблон(ШаблонЗаписи, Запись.Автор, ДоменПочтыДляGit);
			ЗаписьФайла.ЗаписатьСтроку(СтрокаДляЗаписи);
		КонецЦикла;

		ЗаписьФайла.Закрыть();
	Исключение
		ОсвободитьОбъект(ЗаписьФайла);
		ВызватьИсключение;
	КонецПопытки;

КонецПроцедуры


// Определяет необходимость синхронизации хранилища и репо GIT.
//
Функция ТребуетсяСинхронизироватьХранилищеСГит(Знач ФайлХранилища, Знач ЛокальныйКаталогГит) Экспорт

	ТаблицаВерсий = ПрочитатьТаблицуИсторииХранилища(ФайлХранилища);
	ТекущаяВерсия = НомерСинхронизированнойВерсии(ЛокальныйКаталогГит);
	МаксимальнаяВерсияДляРазбора = ОпределитьМаксимальнуюВерсиюВХранилище(ТаблицаВерсий);

	Лог.Информация("Номер синхронизированной версии: " + ТекущаяВерсия);
	Лог.Информация("Номер последней версии в хранилище: " + МаксимальнаяВерсияДляРазбора);

	Возврат ТекущаяВерсия < МаксимальнаяВерсияДляРазбора;

КонецФункции

//////////////////////////////////////
// СЛУЖЕБНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ

Функция ОпределитьМаксимальнуюВерсиюСУчетомОграниченияСверху(Знач ТаблицаИсторииХранилища, Знач ТекущаяВерсия, Знач МаксимальнаяВерсия)

	МаксимальнаяВерсияДляРазбора = 0;
	ЧислоВерсийПлюс = 0;

	Если МаксимальнаяВерсия <> 0 Тогда
		Попытка
			МаксимальнаяВерсия = Число(МаксимальнаяВерсия);
		Исключение
			МаксимальнаяВерсия = 0;
		КонецПопытки;
	КонецЕсли;

	МаксВерсияВХранилище = ОпределитьМаксимальнуюВерсиюВХранилище(ТаблицаИсторииХранилища);

	Если МаксимальнаяВерсия > 0 Тогда
		МаксимальнаяВерсияДляРазбора = Мин(МаксВерсияВХранилище, МаксимальнаяВерсия) ;
	Иначе
		МаксимальнаяВерсияДляРазбора = МаксВерсияВХранилище;
	КонецЕсли;

	Возврат МаксимальнаяВерсияДляРазбора;

КонецФункции

Функция НомерСинхронизированнойВерсии(Знач КаталогВыгрузки)

	ПутьФайлаВерсий = ОбъединитьПути(КаталогВыгрузки, ИмяФайлаВерсииХранилища());

	ТекущаяВерсия = ПрочитатьФайлВерсийГит(ПутьФайлаВерсий);
	Если ТекущаяВерсия <> Неопределено Тогда
		Попытка
			ТекущаяВерсия=Число(ТекущаяВерсия);
		Исключение
			ТекущаяВерсия = 0;
		КонецПопытки;
	Иначе
		ТекущаяВерсия = 0;
	КонецЕсли;

	Возврат ТекущаяВерсия;

КонецФункции

Функция ОпределитьМаксимальнуюВерсиюВХранилище(Знач ТаблицаИсторииХранилища)

	Если ТаблицаИсторииХранилища.Количество() = 0 Тогда
		Возврат 0;
	КонецЕсли;

	МаксимальнаяВерсия = Число(ТаблицаИсторииХранилища[0].НомерВерсии);
	Для Сч = 1 По ТаблицаИсторииХранилища.Количество()-1 Цикл
		ЧислоВерсии = Число(ТаблицаИсторииХранилища[Сч].НомерВерсии);
		Если ЧислоВерсии > МаксимальнаяВерсия Тогда
			МаксимальнаяВерсия = ЧислоВерсии;
		КонецЕсли;
	КонецЦикла;

	Возврат МаксимальнаяВерсия;

КонецФункции

Процедура ВывестиТекстФайла(Знач ИмяФайла, Знач Кодировка = Неопределено)

	Файл = Новый Файл(ИмяФайла);
	Если НЕ Файл.Существует() Тогда
		Возврат;
	КонецЕсли;

	Если Кодировка = Неопределено Тогда
		Кодировка = "utf-8";
	КонецЕсли;

	ЧТ = Новый ЧтениеТекста(ИмяФайла, Кодировка);
	СтрокаФайла = ЧТ.Прочитать();
	ЧТ.Закрыть();

	Лог.Информация(СтрокаФайла);

КонецПроцедуры

Функция ПолучитьТекстФайла(ИмяФайла, резТекстФайла = "")

	// проверим есть ли файл
	Файл = Новый Файл(ИмяФайла);
	Если НЕ Файл.Существует() Тогда
		Лог.Информация("Файл не существует."+ИмяФайла);
		Возврат Ложь;
	КонецЕсли;

	Кодировка = "utf-8";

	ФайлОтчета = Новый ЧтениеТекста(ИмяФайла, Кодировка);
	МассивСтрок = Новый Массив;

	Попытка
		Стр = "";
		Пока Стр <> Неопределено Цикл
			Стр = ФайлОтчета.ПрочитатьСтроку();
			МассивСтрок.Добавить(Стр);
		КонецЦикла;
		ФайлОтчета.Закрыть();
	Исключение
		Лог.Ошибка("При выводе файла возникла ошибка: %1", ОписаниеОшибки());
		Возврат Ложь;
	КонецПопытки;
	Если МассивСтрок.Количество() = 0 Тогда
		Лог.Информация("Файл пуст."+ИмяФайла);
		Возврат Ложь;
	КонецЕсли;

	Лог.Отладка("В файле найдено <"+МассивСтрок.Количество()+"> строк."+ИмяФайла);
	// вывести если строки не нашлись
	текстФайла = "+---/ "+ИмяФайла+" /-------------------------------";
	Для Инд = 0 По МассивСтрок.Количество()-1 Цикл
		текстФайла = текстФайла + Символы.ПС + "|"+МассивСтрок[Инд];
	КонецЦикла;
	текстФайла = текстФайла + Символы.ПС + "+-------------";
	резТекстФайла = текстФайла;

	Возврат Истина;
КонецФункции

Функция ОбернутьВКавычки(Знач Строка)
	Возврат """" + Строка + """";
КонецФункции


////////////////////////////////////////////////////////////////////////////////////////////////
// Общие функции

Функция ИмяФайлаАвторов() Экспорт
	Возврат "AUTHORS";
КонецФункции

Функция ИмяФайлаВерсииХранилища() Экспорт
	Возврат "VERSION"
КонецФункции

Процедура ЗаписатьФайлВерсийГит(Знач КаталогФайлаВерсий, Знач Версия = "") Экспорт

	ПутьКФайлуВерсий = ОбъединитьПути(КаталогФайлаВерсий, ИмяФайлаВерсииХранилища());
	Лог.Отладка("ПутьКФайлуВерсий =<"+ПутьКФайлуВерсий+">");
	Попытка
		Запись = Новый ЗаписьТекста(ПутьКФайлуВерсий, "utf-8");
		Запись.ЗаписатьСтроку("<?xml version=""1.0"" encoding=""UTF-8""?>");
		Запись.ЗаписатьСтроку("<VERSION>" + Версия + "</VERSION>");
		Запись.Закрыть();
	Исключение
		Если Запись <> Неопределено Тогда
			ОсвободитьОбъект(Запись);
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;

КонецПроцедуры

Функция ПрочитатьФайлВерсийГит(Знач ПутьКФайлуВерсий)

	Перем Версия;

	Если Не Новый Файл(ПутьКФайлуВерсий).Существует() Тогда
		ВызватьИсключение "Файл с версией ГИТ <"+ПутьКФайлуВерсий+"> не существует";
	КонецЕсли;

	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.ОткрытьФайл(ПутьКФайлуВерсий);

	Пока ЧтениеXML.Прочитать() Цикл
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента И ЧтениеXML.Имя = "VERSION" Тогда

			Если Не ЧтениеXML.Прочитать() Тогда
				ВызватьИсключение "Чтение файла версий, у элемента Version нет текста";
			КонецЕсли;

			Если Не ЧтениеXML.ТипУзла = ТипУзлаXML.Текст Тогда
				ВызватьИсключение "Чтение файла версий, у элемента Version нет текста";
			КонецЕсли;

			Версия = ЧтениеXML.Значение;
			Лог.Отладка("Предыдущая версия из хранилища 1С: "+Версия);

			лРезультат = Истина;
			Прервать;
		КонецЕсли;

	КонецЦикла;

	ЧтениеXML.Закрыть();

	Возврат Версия;

КонецФункции

Процедура ДобавитьПереименование(Знач Переименования, Знач Источник, Знач Приемник)

	Приемник = СтрЗаменить(Приемник, "/", "\");
	Источник = СтрЗаменить(Источник, "/", "\");
	
	Если Не Источник = Приемник Тогда
		
		СтрокаПереименования = Переименования.Добавить();
		СтрокаПереименования.Источник = Источник;
		СтрокаПереименования.Приемник = Приемник;
			
	КонецЕсли;

КонецПроцедуры

Функция ПрочитатьФайлАвторовГитВТаблицуПользователей(Знач ПутьКФайлуАвторов) Экспорт

	Если НЕ ЗначениеЗаполнено(ПутьКФайлуАвторов) Тогда
		Возврат Неопределено;
	КонецЕсли;

	Файл = Новый Файл(ПутьКФайлуАвторов);
	Если Не Файл.Существует() Тогда
		Возврат НоваяТаблицаПользователейХранилища();
	КонецЕсли;

	Пользователи = НоваяТаблицаПользователейХранилища();

	Попытка
		ТекстовыйФайл = Новый ЧтениеТекста(ПутьКФайлуАвторов,"utf-8");
		СтрокаФайла = "";
		Пока СтрокаФайла <> Неопределено Цикл
			СтрокаФайла = ТекстовыйФайл.ПрочитатьСтроку();
			Индекс = Найти(СтрокаФайла, "=");
			Если Индекс > 0 Тогда

				Ключ = Лев(СтрокаФайла, Индекс-1);
				АвторПредставление = Сред(СтрокаФайла, Индекс+1);

				НоваяСтрока = Пользователи.Добавить();
				НоваяСтрока.ПредставлениеАвтора = АвторПредставление;
				НоваяСтрока.Автор = Ключ;
			КонецЕсли;
		КонецЦикла;

	Исключение
		Если ТекстовыйФайл <> Неопределено Тогда
			ОсвободитьОбъект(ТекстовыйФайл);
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;

	Если ТекстовыйФайл <> Неопределено Тогда
		ОсвободитьОбъект(ТекстовыйФайл);
	КонецЕсли;

	Возврат Пользователи;

КонецФункции

Процедура УстановитьРежимУдаленияВременныхФайлов(ПарамУдалятьВременныеФайлы) Экспорт
	УдалятьВременныеФайлы = ПарамУдалятьВременныеФайлы;
КонецПроцедуры

Процедура НаполнитьКаталогРабочейКопииСлужебнымиДанными(Знач КаталогРабочейКопии, Знач ПутьКХранилищу) Экспорт

	КаталогИсходников = Новый Файл(КаталогРабочейКопии);
	Если Не КаталогИсходников.Существует() Тогда

		СоздатьКаталог(КаталогИсходников.ПолноеИмя);

	ИначеЕсли Не КаталогИсходников.ЭтоКаталог() Тогда
		
		ВызватьИсключение "Невозможно создать каталог " + КаталогИсходников.ПолноеИмя;

	КонецЕсли;

	СгенерироватьФайлAUTHORS(ПутьКХранилищу, КаталогИсходников.ПолноеИмя);
	СгенерироватьФайлVERSION(КаталогИсходников.ПолноеИмя);

КонецПроцедуры // НаполнитьКаталогРабочейКопииСлужебнымиДанными

Процедура СгенерироватьФайлAUTHORS(Знач ПутьХранилища, Знач КаталогИсходников)

	ФайлАвторов = Новый Файл(ОбъединитьПути(КаталогИсходников, "AUTHORS"));
	Если ФайлАвторов.Существует() Тогда
		
		Лог.Информация("Файл " + ФайлАвторов.ПолноеИмя + " уже существует. Пропускаем генерацию файла AUTHORS");
		Возврат;

	КонецЕсли;

	Попытка

		Лог.Отладка("Формирую файл AUTHORS в каталоге " + КаталогИсходников);
		СформироватьПервичныйФайлПользователейДляGit(ПутьХранилища, ФайлАвторов.ПолноеИмя);
		Лог.Отладка("Файл сгенерирован");

	Исключение
		
		Лог.Ошибка("Не удалось сформировать файл авторов");
		ВызватьИсключение;

	КонецПопытки;

КонецПроцедуры // СгенерироватьФайлAUTHORS

Процедура СгенерироватьФайлVERSION(Знач КаталогИсходников)

	ФайлВерсий = Новый Файл(ОбъединитьПути(КаталогИсходников, "VERSION"));
	Если ФайлВерсий.Существует() Тогда
		
		Лог.Информация("Файл " + ФайлВерсий.ПолноеИмя + " уже существует. Пропускаем генерацию файла VERSION");
		Возврат;

	КонецЕсли;

	ЗаписатьФайлВерсийГит(ФайлВерсий.Путь);

КонецПроцедуры // СгенерироватьФайлVERSION

///////////////////////////////////////////////////////////////////////////////////////////////
// Вспомогательные функции

// Удаляет временные файлы при необходимости
// Если передана пустая строка, то удаляются все зарегистрированные временные файлы
//
// Параметры:
//   ПутьКФайлу - Строка - полный путь файла или пустая строка
//
Процедура УдалитьВременныеФайлыПриНеобходимости(Знач ПутьКФайлу = "") Экспорт

	Если УдалятьВременныеФайлы Тогда
		Возврат;
	КонецЕсли;

	Если ПутьКФайлу = "" Тогда
		ВременныеФайлы.Удалить();
	Иначе
		ВременныеФайлы.УдалитьФайл(ПутьКФайлу);
	КонецЕсли;

КонецПроцедуры

Процедура ПриСозданииОбъекта(КлассНастройкиПриложения, ВходящийМенеджерПлагинов = Неопределено)

	Если ВходящийМенеджерПлагинов = Неопределено Тогда
		Плагины = Новый МенеджерПлагинов;
	Иначе
		Плагины = ВходящийМенеджерПлагинов;
	КонецЕсли;

	НастройкиПриложения = КлассНастройкиПриложения;
	Лог = НастройкиПриложения.Лог();
	ДоменПочтыДляGitПоУмолчанию = НастройкиПриложения.Параметры().ДоменПочты;
	УдалятьВременныеФайлы = Ложь;
	МинимальнаяРазницаМеждуКоммитамиНовогоХранилища = 10;
	АвторизацияВХранилище = Новый Структура("ПользовательХранилища, ПарольХранилища");

	Плагины.АктивизироватьПлагины(ЭтотОбъект);
	
КонецПроцедуры

Функция ДатаPOSIX(Знач Дата)

	Возврат "" + Год(Дата) + "-" + ФорматДвузначноеЧисло(Месяц(Дата)) + "-" + ФорматДвузначноеЧисло(День(Дата)) + " "
			+ ФорматДвузначноеЧисло(Час(Дата)) + ":" + ФорматДвузначноеЧисло(Минута(Дата)) + ":" + ФорматДвузначноеЧисло(Секунда(Дата));

КонецФункции

Процедура ДополнитьМассив(Знач Приемник, Знач Источник)

	Для Каждого Элемент Из Источник Цикл
		Приемник.Добавить(Элемент);
	КонецЦикла;

КонецПроцедуры

Процедура УбедитьсяЧтоФайлИлиКаталогСуществует(Знач Путь)

	Файл = Новый Файл(Путь);
	Если Не Файл.Существует() Тогда
		ВызватьИсключение СтроковыеФункции.ПодставитьПараметрыВСтроку("Файл <%1> должен существовать", Путь);
	КонецЕсли;

КонецПроцедуры

Функция ЗапуститьПриложениеИДождатьсяЗавершения(Знач СтрокаЗапуска, Знач ТекущийКаталог = "\.")

	рез = -1;
	Если НЕ ЭтоWindows И ТекущийКаталог = "\." Тогда
		ТекущийКаталог = "./";
	КонецЕсли;

	Попытка
		КодВозврата = "";
		ЗапуститьПриложение(СтрокаЗапуска, ТекущийКаталог, Истина, КодВозврата);
		рез = КодВозврата;
	Исключение
		// Для x64 ОС
		Если ЭтоWindows Тогда
			СтрокаЗапуска = "%windir%\Sysnative\" + СтрокаЗапуска;
			КодВозврата = "";
			ЗапуститьПриложение(СтрокаЗапуска, ТекущийКаталог, Истина, КодВозврата);
			рез = КодВозврата;
		КонецЕсли;
	КонецПопытки;

	Возврат рез;

КонецФункции // ЗапуститьПриложениеИДождатьсяЗавершения()

Процедура ЗавершитьПроцесс_TGitCache_exe()
	Если ЭтоWindows Тогда
		СтрокаКоманды = "taskkill /im TGitCache.exe  /T /F";
		Лог.Отладка("ЗавершитьПроцесс_TGitCache_exe: команда "+ СтрокаКоманды);

		ЗапуститьПриложениеИДождатьсяЗавершения(СтрокаКоманды);
	КонецЕсли;
КонецПроцедуры

Функция ФорматДвузначноеЧисло(ЗначениеЧисло)
	С = Строка(ЗначениеЧисло);
	Если СтрДлина(С) < 2 Тогда
		С = "0" + С;
	КонецЕсли;

	Возврат С;
КонецФункции

Функция ДоменПочтыДляGit()
	Возврат ?(ДоменПочтыДляGitПоУмолчанию = Неопределено, "localhost", ДоменПочтыДляGitПоУмолчанию);
КонецФункции

Процедура УстановитьКоличествоЦикловОжиданияЛицензииПоУмолчанию(КоличествоЦиклов) Экспорт
	КоличествоЦикловОжиданияЛицензииПоУмолчанию = КоличествоЦиклов;
КонецПроцедуры

Функция ПолучитьКоличествоЦикловОжиданияЛицензииПоУмолчанию() Экспорт
	Возврат КоличествоЦикловОжиданияЛицензииПоУмолчанию;
КонецФункции

КоличествоЦикловОжиданияЛицензииПоУмолчанию = 3;

//////////////////////////////////////////////////////////////////////////////////////////////
СистемнаяИнформация = Новый СистемнаяИнформация;
ЭтоWindows = Найти(НРег(СистемнаяИнформация.ВерсияОС), "windows") > 0;


